from datetime import datetime, timedelta


class Goal: #определение класса целей
    def __init__(self, name, total_amount, category, status=None, date_target=None):
        self.name = name
        self.total_amount = total_amount
        self.category = category
        self.current_balance = 0
        self.status = status
        self.history = [] # список кортежей (дата, сумма изменения)
        self.date_target = date_target #крайний срок

        self.update_status()

    def add_money(self, amount):  # пополнение
        if amount < 0:
            raise ValueError('Введите положительное число')
        self.current_balance += amount
        if self.current_balance > self.total_amount:
            self.current_balance = self.total_amount
        self.history.append((datetime.now(), amount))
        self.update_status()

    def withdraw_money(self, amount):  # снятие
        if amount < 0:
            raise ValueError('Введите положительное число')
        self.current_balance -= amount
        if self.current_balance < 0:
            self.current_balance = 0
        self.history.append((datetime.now(), -amount))
        self.update_status()

    def get_progress(self):  # процент выполнения цели
        return (self.current_balance / self.total_amount) * 100 if self.total_amount > 0 else 0

    def update_status(self):  # обновление статуса цели
        if self.current_balance >= self.total_amount:
            self.status = '\nЦель выполнена!'
        else:
            self.status = 'В процессе'

    def dict_goal(self): #создаем словарь
        return {
            "Название цели": self.name,
            "Категория цели": self.category,
            "Сумма цели": self.total_amount,
            "Текущий баланс": self.current_balance,
            "Статус цели": self.status,
            "Дата завершения": self.date_target.strftime('%Y-%m-%d') if self.date_target else None,
            "История": [(dt.strftime('%Y-%m-%d %H:%M'), atm) for dt, atm in self.history]
        }

    @classmethod
    def from_dict(cls, data):
        goal = cls(data.get("Название цели"), data.get("Сумма цели"), data.get('Категория цели'), data.get('Статус цели'))
        goal.current_balance = data.get('Текущий баланс', 0)
        goal.date_target = datetime.strptime(data.get('Дата завершения'), '%Y-%m-%d') if data.get('Дата завершения') else None
        goal.history = [(datetime.strptime(dt_str, '%Y-%m-%d %H:%M'), atm) for dt_str, atm in data.get('История', [])]
        return goal

    def remind_if_due(self):# срок выполнения цели
        if self.date_target is None:
            return 'Дата завершения не указана'
        now = datetime.now().date()
        target_data = self.date_target
        if isinstance(target_data, datetime):
            target_data = target_data.date()
        days_left = (target_data - now).days
        if days_left < 0 and self.current_balance < self.total_amount:
            return f"Внимание! Срок завершения цели прошёл {abs(days_left)} дней назад, а цель ещё не достигнута."
        elif 0 <= days_left <= 3 and self.current_balance < self.total_amount:
            return f"Срок завершения цели наступит через {days_left} дней."
        else:
            return f'Дата завершения {self.date_target.date()}'

    def estimate_completion_date(self): # Рассчитываем средний прирост в день по истории пополнений
        if not self.history:
            return None
        deposits = [h for h in self.history if h[1] > 0]
        if len(deposits) < 2:
            return None  # слишком мало данных для прогноза
        first_date = deposits[0][0]
        last_date = deposits[-1][0]
        total_amount_added = sum([amt for _, amt in deposits])

        days_diff = (last_date - first_date).days
        if days_diff == 0:
            return None  # Не хватает временного интервала
        avg_daily_add = total_amount_added / days_diff
        if avg_daily_add == 0:
            return None  # Нет прогресса
        amount_left = self.total_amount - self.current_balance
        days_needed = amount_left / avg_daily_add
        estimated_date = datetime.now() + timedelta(days=days_needed)
        return estimated_date.strftime('%Y-%m-%d')
